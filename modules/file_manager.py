"""
File Manager Module
Qu·∫£n l√Ω vi·ªác l∆∞u v√† t·∫£i file v·ªõi giao di·ªán ch·ªçn th∆∞ m·ª•c
"""

import os
import shutil
import streamlit as st
import datetime
from typing import List, Dict, Optional, Tuple
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

class FileManager:
    """Class qu·∫£n l√Ω file v√† th∆∞ m·ª•c"""
    
    def __init__(self):
        self.default_save_dir = "outputs"
    
    def get_save_directory_ui(self, title: str = "Ch·ªçn th∆∞ m·ª•c l∆∞u", 
                            default_path: str = None) -> Optional[str]:
        """
        Hi·ªÉn th·ªã giao di·ªán ch·ªçn th∆∞ m·ª•c l∆∞u
        
        Args:
            title: Ti√™u ƒë·ªÅ dialog
            default_path: ƒê∆∞·ªùng d·∫´n m·∫∑c ƒë·ªãnh
            
        Returns:
            str: ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c ƒë√£ ch·ªçn ho·∫∑c None
        """
        st.markdown(f"### üìÅ {title}")
        
        # T√πy ch·ªçn l∆∞u
        save_option = st.radio(
            "Ch·ªçn c√°ch l∆∞u:",
            ["L∆∞u v√†o th∆∞ m·ª•c m·∫∑c ƒë·ªãnh", "Ch·ªçn th∆∞ m·ª•c kh√°c"],
            horizontal=True,
            key=f"save_option_{title.replace(' ', '_')}"
        )
        
        if save_option == "L∆∞u v√†o th∆∞ m·ª•c m·∫∑c ƒë·ªãnh":
            return self.default_save_dir
        
        # Ch·ªçn th∆∞ m·ª•c kh√°c
        st.markdown("**Ch·ªçn th∆∞ m·ª•c l∆∞u:**")
        
        # Hi·ªÉn th·ªã c√°c ·ªï ƒëƒ©a v√† th∆∞ m·ª•c ph·ªï bi·∫øn
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**·ªî ƒëƒ©a:**")
            drives = self._get_available_drives()
            selected_drive = st.selectbox("Ch·ªçn ·ªï ƒëƒ©a:", drives, key=f"drive_selector_{title.replace(' ', '_')}")
        
        with col2:
            st.markdown("**Th∆∞ m·ª•c ph·ªï bi·∫øn:**")
            common_dirs = self._get_common_directories(selected_drive)
            selected_dir = st.selectbox("Ch·ªçn th∆∞ m·ª•c:", common_dirs, key=f"dir_selector_{title.replace(' ', '_')}")
        
        # Nh·∫≠p ƒë∆∞·ªùng d·∫´n t√πy ch·ªânh
        st.markdown("**Ho·∫∑c nh·∫≠p ƒë∆∞·ªùng d·∫´n t√πy ch·ªânh:**")
        custom_path = st.text_input(
            "ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c:",
            value=selected_dir,
            placeholder=f"V√≠ d·ª•: {selected_drive}\\MyProject\\Videos",
            help="Nh·∫≠p ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß ƒë·∫øn th∆∞ m·ª•c mu·ªën l∆∞u",
            key=f"custom_path_{title.replace(' ', '_')}"
        )
        
        # X√°c nh·∫≠n
        if st.button("‚úÖ X√°c nh·∫≠n th∆∞ m·ª•c", key=f"confirm_dir_{title.replace(' ', '_')}"):
            if custom_path and os.path.exists(os.path.dirname(custom_path)):
                return custom_path
            elif custom_path:
                # T·∫°o th∆∞ m·ª•c m·ªõi n·∫øu ch∆∞a t·ªìn t·∫°i
                try:
                    os.makedirs(custom_path, exist_ok=True)
                    st.success(f"‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c: {custom_path}")
                    return custom_path
                except Exception as e:
                    st.error(f"‚ùå Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c: {e}")
                    return None
            else:
                st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c")
                return None
        
        return None
    
    def _get_available_drives(self) -> List[str]:
        """L·∫•y danh s√°ch c√°c ·ªï ƒëƒ©a c√≥ s·∫µn"""
        drives = []
        try:
            # S·ª≠ d·ª•ng psutil ƒë·ªÉ l·∫•y danh s√°ch ·ªï ƒëƒ©a ch√≠nh x√°c h∆°n
            import psutil
            partitions = psutil.disk_partitions()
            for partition in partitions:
                if partition.device and os.path.exists(partition.device):
                    drives.append(partition.device)
        except ImportError:
            # Fallback: ki·ªÉm tra t·ª´ng ·ªï ƒëƒ©a
            import subprocess
            try:
                # S·ª≠ d·ª•ng wmic ƒë·ªÉ l·∫•y danh s√°ch ·ªï ƒëƒ©a tr√™n Windows
                result = subprocess.run(['wmic', 'logicaldisk', 'get', 'size,freespace,caption'], 
                                      capture_output=True, text=True, shell=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:  # B·ªè header
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 1:
                                drive = parts[0].strip()
                                if drive and os.path.exists(drive):
                                    drives.append(drive)
            except:
                # Fallback cu·ªëi c√πng: ki·ªÉm tra t·ª´ng ·ªï ƒëƒ©a
                for drive in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
                    drive_path = f"{drive}:\\"
                    try:
                        if os.path.exists(drive_path):
                            drives.append(drive_path)
                    except:
                        continue
        
        # N·∫øu kh√¥ng t√¨m th·∫•y ·ªï ƒëƒ©a n√†o, th√™m C: m·∫∑c ƒë·ªãnh
        if not drives:
            drives = ["C:\\"]
        
        return drives
    
    def _get_common_directories(self, drive: str) -> List[str]:
        """L·∫•y danh s√°ch th∆∞ m·ª•c ph·ªï bi·∫øn"""
        common_dirs = [
            f"{drive}Users\\{os.getenv('USERNAME', 'User')}\\Desktop",
            f"{drive}Users\\{os.getenv('USERNAME', 'User')}\\Documents",
            f"{drive}Users\\{os.getenv('USERNAME', 'User')}\\Downloads",
            f"{drive}Users\\{os.getenv('USERNAME', 'User')}\\Videos",
            f"{drive}Users\\{os.getenv('USERNAME', 'User')}\\Pictures",
            f"{drive}Projects",
            f"{drive}MyProject",
            f"{drive}Videos",
            f"{drive}AI_Videos"
        ]
        
        # L·ªçc ch·ªâ nh·ªØng th∆∞ m·ª•c t·ªìn t·∫°i
        existing_dirs = []
        for dir_path in common_dirs:
            if os.path.exists(dir_path):
                existing_dirs.append(dir_path)
        
        return existing_dirs if existing_dirs else [f"{drive}"]
    
    def save_project_with_images(self, scenes: List[Dict], image_paths: List[str], 
                               save_directory: str, project_name: str = None,
                               separate_files: bool = True) -> Dict[str, str]:
        """
        L∆∞u to√†n b·ªô d·ª± √°n (script + ·∫£nh) v√†o th∆∞ m·ª•c ƒë√£ ch·ªçn
        
        Args:
            scenes: Danh s√°ch c√°c c·∫£nh
            image_paths: Danh s√°ch ƒë∆∞·ªùng d·∫´n ·∫£nh
            save_directory: Th∆∞ m·ª•c l∆∞u
            project_name: T√™n d·ª± √°n
            separate_files: T√°ch c√°c file ri√™ng bi·ªát (script, dialogue, prompts)
            
        Returns:
            Dict: Th√¥ng tin c√°c file ƒë√£ l∆∞u
        """
        if not project_name:
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            project_name = f"AI_Video_Project_{timestamp}"
        
        # T·∫°o th∆∞ m·ª•c d·ª± √°n
        project_dir = os.path.join(save_directory, project_name)
        os.makedirs(project_dir, exist_ok=True)
        
        # T·∫°o c√°c th∆∞ m·ª•c con
        scripts_dir = os.path.join(project_dir, "scripts")
        images_dir = os.path.join(project_dir, "images")
        dialogues_dir = os.path.join(project_dir, "dialogues")
        prompts_dir = os.path.join(project_dir, "prompts")
        
        os.makedirs(scripts_dir, exist_ok=True)
        os.makedirs(images_dir, exist_ok=True)
        if separate_files:
            os.makedirs(dialogues_dir, exist_ok=True)
            os.makedirs(prompts_dir, exist_ok=True)
        
        saved_files = {
            "project_dir": project_dir,
            "scripts_dir": scripts_dir,
            "images_dir": images_dir,
            "dialogues_dir": dialogues_dir if separate_files else None,
            "prompts_dir": prompts_dir if separate_files else None
        }
        
        try:
            # L∆∞u script JSON
            from .script_generator import ScriptGenerator
            script_gen = ScriptGenerator()
            
            json_path = script_gen.save_script(
                scenes, 
                filename=f"{project_name}.json",
                save_directory=scripts_dir
            )
            saved_files["script_json"] = json_path
            
            # L∆∞u script Text
            text_path = script_gen.save_script_as_text(
                scenes,
                filename=f"{project_name}.txt",
                save_directory=scripts_dir
            )
            saved_files["script_text"] = text_path
            
            # Copy ·∫£nh
            copied_images = []
            for i, image_path in enumerate(image_paths):
                if os.path.exists(image_path):
                    filename = f"scene_{i+1:02d}.png"
                    dest_path = os.path.join(images_dir, filename)
                    shutil.copy2(image_path, dest_path)
                    copied_images.append(dest_path)
            
            saved_files["images"] = copied_images
            
            # T√°ch file ri√™ng bi·ªát n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
            if separate_files:
                # T√°ch dialogue
                dialogue_files = self._save_dialogues_separately(scenes, dialogues_dir, project_name)
                saved_files["dialogues"] = dialogue_files
                
                # T√°ch image prompts
                prompt_files = self._save_prompts_separately(scenes, prompts_dir, project_name)
                saved_files["prompts"] = prompt_files
            
            # T·∫°o file README
            readme_path = self._create_project_readme(project_dir, project_name, scenes, copied_images)
            saved_files["readme"] = readme_path
            
            logger.info(f"Project saved to: {project_dir}")
            return saved_files
            
        except Exception as e:
            logger.error(f"Error saving project: {e}")
            raise
    
    def _create_project_readme(self, project_dir: str, project_name: str, 
                             scenes: List[Dict], image_paths: List[str]) -> str:
        """T·∫°o file README cho d·ª± √°n"""
        readme_path = os.path.join(project_dir, "README.md")
        
        # Ki·ªÉm tra xem c√≥ t√°ch file ri√™ng kh√¥ng
        has_separate_files = any(scene.get('dialogue') for scene in scenes)
        
        content = f"""# {project_name}

## üìã Th√¥ng tin d·ª± √°n
- **Ng√†y t·∫°o:** {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
- **T·ªïng s·ªë c·∫£nh:** {len(scenes)}
- **T·ªïng th·ªùi l∆∞·ª£ng:** {sum(scene.get('duration', 3) for scene in scenes)} gi√¢y

## üìÅ C·∫•u tr√∫c th∆∞ m·ª•c
```
{project_name}/
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ {project_name}.json    # Script ƒë·ªãnh d·∫°ng JSON
‚îÇ   ‚îî‚îÄ‚îÄ {project_name}.txt     # Script ƒë·ªãnh d·∫°ng text
‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ scene_01.png           # ·∫¢nh c·∫£nh 1
‚îÇ   ‚îú‚îÄ‚îÄ scene_02.png           # ·∫¢nh c·∫£nh 2
‚îÇ   ‚îî‚îÄ‚îÄ ...                    # C√°c ·∫£nh kh√°c"""
        
        if has_separate_files:
            content += f"""
‚îú‚îÄ‚îÄ dialogues/
‚îÇ   ‚îú‚îÄ‚îÄ {project_name}_dialogues.txt  # T·∫•t c·∫£ dialogue
‚îÇ   ‚îú‚îÄ‚îÄ scene_01_dialogue.txt         # Dialogue c·∫£nh 1
‚îÇ   ‚îî‚îÄ‚îÄ ...                           # Dialogue c√°c c·∫£nh kh√°c
‚îú‚îÄ‚îÄ prompts/
‚îÇ   ‚îú‚îÄ‚îÄ {project_name}_prompts.txt    # T·∫•t c·∫£ image prompts
‚îÇ   ‚îú‚îÄ‚îÄ scene_01_prompt.txt           # Prompt c·∫£nh 1
‚îÇ   ‚îî‚îÄ‚îÄ ...                           # Prompt c√°c c·∫£nh kh√°c"""
        
        content += f"""
‚îî‚îÄ‚îÄ README.md                  # File n√†y
```

## üé¨ Danh s√°ch c·∫£nh
"""
        
        for i, scene in enumerate(scenes, 1):
            content += f"""
### C·∫£nh {i}: {scene.get('title', f'Scene {i}')}
- **M√¥ t·∫£:** {scene.get('description', 'Kh√¥ng c√≥ m√¥ t·∫£')}
- **Th·ªùi l∆∞·ª£ng:** {scene.get('duration', 3)} gi√¢y
- **Chuy·ªÉn c·∫£nh:** {scene.get('transition', 'fade')}
- **·∫¢nh:** scene_{i:02d}.png
"""
        
        content += f"""
## üöÄ C√°ch s·ª≠ d·ª•ng

1. **Xem script:** M·ªü file `{project_name}.txt` ƒë·ªÉ xem k·ªãch b·∫£n chi ti·∫øt
2. **T·∫°o video:** S·ª≠ d·ª•ng c√°c ·∫£nh trong th∆∞ m·ª•c `images/` ƒë·ªÉ t·∫°o video
3. **Ch·ªânh s·ª≠a:** C√≥ th·ªÉ ch·ªânh s·ª≠a script v√† ·∫£nh theo √Ω mu·ªën"""
        
        if has_separate_files:
            content += f"""
4. **S·ª≠ d·ª•ng dialogue:** M·ªü file trong th∆∞ m·ª•c `dialogues/` ƒë·ªÉ xem l·ªùi tho·∫°i
5. **S·ª≠ d·ª•ng prompts:** M·ªü file trong th∆∞ m·ª•c `prompts/` ƒë·ªÉ xem image prompts
6. **T·∫°o voice-over:** S·ª≠ d·ª•ng dialogue ƒë·ªÉ t·∫°o gi·ªçng ƒë·ªçc cho video"""
        
        content += f"""

## üìù Ghi ch√∫
- D·ª± √°n ƒë∆∞·ª£c t·∫°o b·ªüi AI Video Generator
- C√≥ th·ªÉ s·ª≠ d·ª•ng v·ªõi Google Flow ho·∫∑c c√°c c√¥ng c·ª• t·∫°o video kh√°c
- ·∫¢nh c√≥ th·ªÉ ƒë∆∞·ª£c thay th·∫ø ho·∫∑c ch·ªânh s·ª≠a"""
        
        if has_separate_files:
            content += f"""
- Dialogue v√† prompts ƒë∆∞·ª£c t√°ch ri√™ng ƒë·ªÉ d·ªÖ s·ª≠ d·ª•ng
- C√≥ th·ªÉ ch·ªânh s·ª≠a dialogue v√† prompts theo √Ω mu·ªën"""
        
        content += f"""
"""
        
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        return readme_path
    
    def _save_dialogues_separately(self, scenes: List[Dict], dialogues_dir: str, project_name: str) -> List[str]:
        """T√°ch dialogue th√†nh file ri√™ng bi·ªát"""
        dialogue_files = []
        
        # T·∫°o file dialogue t·ªïng h·ª£p
        all_dialogues = []
        for i, scene in enumerate(scenes, 1):
            dialogue = scene.get('dialogue', '')
            dialogue_type = scene.get('dialogue_type', 'none')
            
            if dialogue and dialogue_type != 'none':
                all_dialogues.append(f"üé¨ C·∫¢NH {i}: {scene.get('title', f'Scene {i}')}")
                all_dialogues.append("-" * 50)
                
                if dialogue_type == 'character':
                    all_dialogues.append(f"üí¨ L·ªùi tho·∫°i nh√¢n v·∫≠t:")
                    all_dialogues.append(f"   {dialogue}")
                elif dialogue_type == 'narration':
                    all_dialogues.append(f"üìñ L·ªùi k·ªÉ chuy·ªán:")
                    all_dialogues.append(f"   {dialogue}")
                
                all_dialogues.append("")
        
        # L∆∞u file dialogue t·ªïng h·ª£p
        if all_dialogues:
            dialogue_file = os.path.join(dialogues_dir, f"{project_name}_dialogues.txt")
            with open(dialogue_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(all_dialogues))
            dialogue_files.append(dialogue_file)
        
        # T·∫°o file dialogue cho t·ª´ng c·∫£nh
        for i, scene in enumerate(scenes, 1):
            dialogue = scene.get('dialogue', '')
            dialogue_type = scene.get('dialogue_type', 'none')
            
            if dialogue and dialogue_type != 'none':
                scene_dialogue_file = os.path.join(dialogues_dir, f"scene_{i:02d}_dialogue.txt")
                with open(scene_dialogue_file, 'w', encoding='utf-8') as f:
                    f.write(f"üé¨ C·∫¢NH {i}: {scene.get('title', f'Scene {i}')}\n")
                    f.write("-" * 50 + "\n")
                    
                    if dialogue_type == 'character':
                        f.write(f"üí¨ L·ªùi tho·∫°i nh√¢n v·∫≠t:\n")
                        f.write(f"   {dialogue}\n")
                    elif dialogue_type == 'narration':
                        f.write(f"üìñ L·ªùi k·ªÉ chuy·ªán:\n")
                        f.write(f"   {dialogue}\n")
                
                dialogue_files.append(scene_dialogue_file)
        
        return dialogue_files
    
    def _save_prompts_separately(self, scenes: List[Dict], prompts_dir: str, project_name: str) -> List[str]:
        """T√°ch image prompts th√†nh file ri√™ng bi·ªát"""
        prompt_files = []
        
        # T·∫°o file prompts t·ªïng h·ª£p
        all_prompts = []
        for i, scene in enumerate(scenes, 1):
            all_prompts.append(f"üé¨ C·∫¢NH {i}: {scene.get('title', f'Scene {i}')}")
            all_prompts.append("-" * 50)
            all_prompts.append(f"üé® Image Prompt:")
            all_prompts.append(f"   {scene.get('image_prompt', 'Kh√¥ng c√≥ prompt')}")
            all_prompts.append("")
        
        # L∆∞u file prompts t·ªïng h·ª£p
        if all_prompts:
            prompts_file = os.path.join(prompts_dir, f"{project_name}_prompts.txt")
            with open(prompts_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(all_prompts))
            prompt_files.append(prompts_file)
        
        # T·∫°o file prompt cho t·ª´ng c·∫£nh
        for i, scene in enumerate(scenes, 1):
            scene_prompt_file = os.path.join(prompts_dir, f"scene_{i:02d}_prompt.txt")
            with open(scene_prompt_file, 'w', encoding='utf-8') as f:
                f.write(f"üé¨ C·∫¢NH {i}: {scene.get('title', f'Scene {i}')}\n")
                f.write("-" * 50 + "\n")
                f.write(f"üé® Image Prompt:\n")
                f.write(f"   {scene.get('image_prompt', 'Kh√¥ng c√≥ prompt')}\n")
            
            prompt_files.append(scene_prompt_file)
        
        return prompt_files
    
    def get_download_links_ui(self, saved_files: Dict[str, str]) -> None:
        """
        Hi·ªÉn th·ªã giao di·ªán download c√°c file ƒë√£ l∆∞u
        
        Args:
            saved_files: Th√¥ng tin c√°c file ƒë√£ l∆∞u
        """
        st.markdown("### üì• T·∫£i xu·ªëng files")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**üìÑ Script files:**")
            
            # Script JSON
            if "script_json" in saved_files:
                with open(saved_files["script_json"], 'rb') as f:
                    st.download_button(
                        label="üìÑ T·∫£i Script JSON",
                        data=f.read(),
                        file_name=os.path.basename(saved_files["script_json"]),
                        mime="application/json"
                    )
            
            # Script Text
            if "script_text" in saved_files:
                with open(saved_files["script_text"], 'rb') as f:
                    st.download_button(
                        label="üìù T·∫£i Script Text",
                        data=f.read(),
                        file_name=os.path.basename(saved_files["script_text"]),
                        mime="text/plain"
                    )
        
        with col2:
            st.markdown("**üñºÔ∏è ·∫¢nh files:**")
            
            if "images" in saved_files:
                for i, image_path in enumerate(saved_files["images"]):
                    with open(image_path, 'rb') as f:
                        st.download_button(
                            label=f"üñºÔ∏è T·∫£i ·∫£nh {i+1}",
                            data=f.read(),
                            file_name=os.path.basename(image_path),
                            mime="image/png",
                            key=f"download_image_{i}"
                        )
        
        # Hi·ªÉn th·ªã dialogue v√† prompts n·∫øu c√≥
        if "dialogues" in saved_files and saved_files["dialogues"]:
            st.markdown("**üí¨ Dialogue files:**")
            for i, dialogue_path in enumerate(saved_files["dialogues"]):
                with open(dialogue_path, 'rb') as f:
                    st.download_button(
                        label=f"üí¨ T·∫£i dialogue {i+1}",
                        data=f.read(),
                        file_name=os.path.basename(dialogue_path),
                        mime="text/plain",
                        key=f"download_dialogue_{i}"
                    )
        
        if "prompts" in saved_files and saved_files["prompts"]:
            st.markdown("**üé® Prompt files:**")
            for i, prompt_path in enumerate(saved_files["prompts"]):
                with open(prompt_path, 'rb') as f:
                    st.download_button(
                        label=f"üé® T·∫£i prompt {i+1}",
                        data=f.read(),
                        file_name=os.path.basename(prompt_path),
                        mime="text/plain",
                        key=f"download_prompt_{i}"
                    )
        
        # T·∫£i to√†n b·ªô d·ª± √°n
        st.markdown("**üì¶ T·∫£i to√†n b·ªô d·ª± √°n:**")
        if st.button("üì¶ T·∫°o file ZIP d·ª± √°n"):
            try:
                import zipfile
                project_dir = saved_files["project_dir"]
                zip_path = f"{project_dir}.zip"
                
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for root, dirs, files in os.walk(project_dir):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, project_dir)
                            zipf.write(file_path, arcname)
                
                with open(zip_path, 'rb') as f:
                    st.download_button(
                        label="üì¶ T·∫£i file ZIP",
                        data=f.read(),
                        file_name=os.path.basename(zip_path),
                        mime="application/zip"
                    )
                
                # X√≥a file zip t·∫°m
                os.remove(zip_path)
                
            except Exception as e:
                st.error(f"‚ùå L·ªói t·∫°o file ZIP: {e}")


# H√†m ti·ªán √≠ch
def get_save_directory(title: str = "Ch·ªçn th∆∞ m·ª•c l∆∞u") -> Optional[str]:
    """H√†m ti·ªán √≠ch ƒë·ªÉ l·∫•y th∆∞ m·ª•c l∆∞u"""
    file_manager = FileManager()
    return file_manager.get_save_directory_ui(title)
